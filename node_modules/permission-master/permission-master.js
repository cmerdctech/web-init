'use strict';
const qtoolsGen = require('qtools');
const qtools = new qtoolsGen(module);
const jwt = require('jsonwebtoken');

//START OF moduleFunction() ============================================================

var moduleFunction = function(args) {
	qtools.validateProperties({
		subject: args || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'config',
				optional: false
			}
		]
	});

	qtools.validateProperties({
		subject: this.config.permissionMaster || {},
		targetScope: this, //will add listed items to targetScope
		propList: [
			{
				name: 'roleList',
				optional: false
			},
			{
				name: 'publicFileRoleName',
				optional: false
			},
			{
				name: 'sessionExpireMinutes',
				optional: false
			},
			{
				name: 'jwtSecret',
				optional: false
			}
		]
	});

	this.routeList = [];

	//LOCAL VARIABLES ====================================

	//LOCAL FUNCTIONS ====================================

	//METHODS AND PROPERTIES ====================================

	this.shutdown = (message, callback) => {
		console.log(`shutting down ${__dirname}`);
		callback('', message);
	};

	this.getRole = (name, callback) => {
		const role = qtools.getByProperty(this.roleList, 'name', name);
		if (!role) {
			if (callback) {
				callback(`no such role as $(roleName) in configuration`);
			} else {
				throw `no such role as $(roleName) in configuration`;
			}
		} else {
			if (callback) {
				callback('', role);
			} else {
				return role;
			}
		}
	};

	this.addRoute = (method, route, role) => {
		this.routeList.push({
			route: route,
			role: role,
			method: method
		});
	};

	const getByPath = (path, method) => {
		for (var i = 0, len = this.routeList.length; i < len; i++) {
			var element = this.routeList[i];
			if (path.match(element.route)) {
				if (!element.method) {
					return element;
				}

				if (
					element.method && element.method.toLowerCase() == method.toLowerCase()
				) {
					return element;
				}
			}
		}
		return;
	};

	const badToken = req => {
		const routeItem = getByPath(req.path, req.method);
		if (!routeItem) {
			return {
				code: '404',
				message: 'Not Found'
			};
		}
		if (req.token && req.token.jwt) {
			try {
				var decoded = jwt.verify(req.token.jwt, this.jwtSecret);
				req.tokenJwtDecoded = decoded;
			} catch (e) {
				return 'Invalid Token Format';
			}
		}
		if (routeItem.role == this.config.permissionMaster.publicFileRoleName) {
			req.publicRole = true;
			return false;
		} else {
			if (!req.tokenJwtDecoded) {
				return 'No Session Token Found';
			}
			if (decoded.expiration < Date.now()) {
				return 'Session Expired';
			}
			if (!routeItem.role) {
				return 'Internal Error - Path has no role';
			}
			if (!decoded.role) {
				return 'Malformed token - no role included';
			}
			if (!routeItem.role.match(decoded.role)) {
				return 'Invalid Role';
			}
			return false;
		}
	};

	this.checkPath = (req, res, next) => {
		const isBad = badToken(req);
		if (!isBad) {
			next();
		} else {
			if (typeof isBad == 'object') {
				next(isBad);
			} else {
				next({
					code: '401',
					message: isBad
				});
			}
		}
	};

	this.getToken = (role, otherData) => {
		otherData = otherData ? otherData : {};
		const expTime = Date.now() + this.sessionExpireMinutes * 60000;
		let claims = { role, expiration: expTime };
		claims = Object.assign(claims, otherData);
		return {
			claims: claims,
			jwt: jwt.sign(claims, this.jwtSecret)
		};
	};

	this.updateToken = function(req, otherData) {
		otherData = otherData ? otherData : {};
		if (!req.tokenJwtDecoded && req.publicRole) {
			return {
				public: true
			};
		}
		const expTime = Date.now() + this.sessionExpireMinutes * 60000;
		const claims = {
			role: req.tokenJwtDecoded.role,
			expiration: expTime,
			userRefId: req.tokenJwtDecoded.userRefId,
			_id: req.tokenJwtDecoded._id
		};
		claims = Object.assign(claims, otherData);
		return {
			claims: claims,
			jwt: jwt.sign(claims, this.jwtSecret)
		};
	};

	//revise this to make it a standard func(control, args, callback) structure.
	this.getAccessControl = controls => {
		const role = controls.role ? controls.role : '';
		const method = controls.method ? controls.method : 'get';
		if (!role) {
			console.log(
				`permissionMaster.getAccessControl() says, Role specification is empty for ${controls.clientName}.`
			);
		}
		return urlRegex => {
			let finalRole;
			if (typeof role == 'function') {
				finalRole = role(urlRegex);
			} else {
				finalRole = role;
			}
			let finalMethod;
			if (typeof method == 'function') {
				finalMethod = method(urlRegex);
			} else {
				finalMethod = method;
			}
			this.addRoute(finalMethod, urlRegex, finalRole);
		};
	};

	//API ENDPOINTS ====================================

	//INITIALIZATION ====================================

	return this;
};

//END OF moduleFunction() ============================================================

module.exports = moduleFunction;
//module.exports = new moduleFunction();
